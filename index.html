<!DOCTYPE html>
<html>

<head>

    <link rel="icon" type="image/x-icon" href="/favicon.ico" />
    <meta charset="utf-8">
    <title>FishIT</title>

    <link rel="stylesheet" type="text/css" href="css/index.css">
</head>



<body>

    <script src="js/libs/x-tag-core.min.js"></script>
    <script src="templates/progress-bars.js"></script>
    <script src="js/three.js"></script>
    <script src="js/GLTFLoader.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/Water2.js"></script>
    <script src="js/Reflector.js"></script>
    <script src="js/Refractor.js"></script>
    <script src="js/Sky.js"></script>
    <script src="js/libs/stats.min.js"></script>
    <script src="js/KeyboardState.js"></script>

    <div id="container"><br /><br /><br /><br /><br />Loading...</div>

    <div id="progressBar">

        <circular-progress-bar id="bar-1" barcolor="#EE5C42" filledcolor="#8B3626" progressStringFormat="Press SPACE"
            displayTextWhenDone="false">
        </circular-progress-bar>

    </div>

    <script>
        var pesce = [];
        var boat;
        var lighthouse;
        var boatFlag = false;
        var fishFlag = false;
        var flag = false;
        var helper;
        var boxes = [];
        var movingCubes = [];
        var collidableMeshList = [];
        var container, stats;
        var scene, renderer, camera;
        var light, light2;
        var progress;
        var quickTime = false;
        var keyboard = new KeyboardState();
        var bar = document.getElementById("bar-1");
        var xAxis = new THREE.Vector3(1, 0, 0);


        ///////////////////
        //QUICKTIME EVENT
        ///////////////////

        function SetBarsAsUndefined() {
            bar.setUndeterminated(1);
        }

        function SetBarsAsDefined() {
            bar.setUndeterminated(0);
        }

        function UpdateBars() {
            bar.progress++;
            if (document.getElementById("bar-1").progress < 100) {
                setTimeout(UpdateBars, 10);
            }
        }
        // Converts from degrees to radians.
        Math.radians = function (degrees) {
            return degrees * Math.PI / 180;
        };

        // Converts from radians to degrees.
        Math.degrees = function (radians) {
            return radians * 180 / Math.PI;
        };

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }



        init();
        initBasicGraphics();
        initCustomModels();

        function init() {
            ///////////////////
            //CAMERA
            ///////////////////

            container = document.getElementById('container');

            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0xcce0ff, 500, 10000);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 100000);
            camera.position.set(159, 10, 552);

            //ORBIT CONTROL
            //var controls = new THREE.OrbitControls(camera);
            //controls.update();

            camera.lookAt(0, 0, 0);
            window.addEventListener('mousemove', function (e) {
                var mouse3D = new THREE.Vector3(
                    ((event.clientX / window.innerWidth) * 2 - 1) * 300,
                    (-(event.clientY / window.innerHeight) * 2 + 1) * 300,
                    0.5);
                camera.lookAt(mouse3D);
            });

            /* IF YOU NEED A 360 DEGREES CAMERA, YOU CAN USE POINTERLOCKCONTROL
            EXAMPLE IS DINO:
            https://codepen.io/MSEdgeDev/pen/NpKejy */

            /* var looking = new THREE.PointerLockControls( camera );
            scene.add( looking.getObject() ); */
            //looking.enabled = true; // Turns on camera rotating with mouse


            ///////////////////
            //LIGHTS & SHADOWS
            ///////////////////


            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap

            light2 = new THREE.AmbientLight(0x404040); // soft white light
            scene.add(light2);

            light = new THREE.DirectionalLight(0xffffff, 3);
            light.position.set(400, 400, 400);
            light.castShadow = true;
            scene.add(light);
            //Set up shadow properties for the light
            light.shadow.mapSize.width = 512; // default
            light.shadow.mapSize.height = 512; // default
            light.shadow.camera.near = 0.5; // default
            light.shadow.camera.far = 500 // default

            container.innerHTML = "";
            container.appendChild(renderer.domElement);

            //STATS TOP LEFT
            stats = new Stats();
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.top = '0px'
            container.appendChild(stats.domElement);

            //PROGRESS BAR
            progress = document.getElementById('progressBar');
            progress.style.position = 'absolute';
            progress.style.top = '50%';
            progress.style.left = '50%';
            progress.style.visibility = 'hidden';
            container.appendChild(progress);

            window.addEventListener('resize', onWindowResize, false);
        }


        function initBasicGraphics() {

            ///////////////////
            //WATER
            ///////////////////

            var params = {
                color: '#ffffff',
                scale: 4,
                flowX: 1,
                flowY: 1
            };

            var waterGeometry = new THREE.PlaneBufferGeometry(2000, 2000);
            water = new THREE.Water(waterGeometry, {
                color: params.color,
                scale: params.scale,
                flowDirection: new THREE.Vector2(params.flowX, params.flowY),
                textureWidth: 1024,
                textureHeight: 1024
            });
            water.position.y = -11;
            water.rotation.x = Math.PI * -0.5;
            scene.add(water);


            ///////////////////
            //SKY
            ///////////////////

            // Add Sky
            sky = new THREE.Sky();
            sky.scale.setScalar(450000);
            scene.add(sky);

            // Add Sun Helper
            sunSphere = new THREE.Mesh(
                new THREE.SphereBufferGeometry(20000, 16, 8),
                new THREE.MeshBasicMaterial({
                    color: 0xffffff
                })
            );
            sunSphere.position.y = -700000;
            sunSphere.visible = false;
            scene.add(sunSphere);

            var distance = 400000;

            var effectController = {
                turbidity: 10,
                rayleigh: 2,
                mieCoefficient: 0.005,
                mieDirectionalG: 0.8,
                luminance: 1,
                inclination: 0.55, // elevation / inclination
                azimuth: 0.6, // Facing front,
                sun: !true
            };

            var uniforms = sky.material.uniforms;
            uniforms.turbidity.value = effectController.turbidity;
            uniforms.rayleigh.value = effectController.rayleigh;
            uniforms.luminance.value = effectController.luminance;
            uniforms.mieCoefficient.value = effectController.mieCoefficient;
            uniforms.mieDirectionalG.value = effectController.mieDirectionalG;
            var theta = Math.PI * (effectController.inclination - 0.5);
            var phi = 2 * Math.PI * (effectController.azimuth - 0.5);
            sunSphere.position.x = distance * Math.cos(phi);
            sunSphere.position.y = distance * Math.sin(phi) * Math.sin(theta);
            sunSphere.position.z = distance * Math.sin(phi) * Math.cos(theta);
            sunSphere.visible = effectController.sun;
            uniforms.sunPosition.value.copy(sunSphere.position);
        }

        function initCustomModels() {
            ///////////////////
            //3D MODELS
            ///////////////////
            var loader = new THREE.GLTFLoader();

            loader.load(
                '/models/lighthouse/model.gltf',
                function (gltf) {
                    gltf.scene.castShadow = true;
                    gltf.scene.name = "lighthouse";
                    gltf.scene.position.y = -13;

                    lighthouse = gltf.scene;
                    scene.add(lighthouse);
                },
                function (xhr) {
                    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                    if (xhr.loaded / xhr.total == 1) {}
                },
                function (error) {
                    console.log('An error happened');
                }
            );

            loader.load(
                '/models/boat/scene.gltf',
                function (gltf) {
                    gltf.scene.castShadow = true;
                    gltf.scene.name = "boat";
                    gltf.scene.position.set(270, -8, 600);
                    gltf.scene.scale.set(10, 10, 10);

                    boat = gltf.scene;
                    scene.add(boat);
                    boatFlag = true;

                },
                function (xhr) {
                    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                    if (xhr.loaded / xhr.total == 1) {}
                },
                function (error) {
                    console.log('An error happened');
                }
            );

            loader.load(
                '/models/rod/scene.gltf',
                function (gltf) {
                    gltf.scene.position.set(170, 10, 570);
                    gltf.scene.scale.set(5, 5, 5);
                    gltf.scene.castShadow = true;
                    scene.add(gltf.scene);
                },
                function (xhr) {
                    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                },
                function (error) {
                    console.log('An error happened');
                }
            );

            loader.load(
                '/models/fish/scene.gltf',
                function (gltf) {
                    gltf.scene.scale.set(0.05, 0.05, 0.05);
                    gltf.scene.castShadow = true;
                    for (var i = 0; i < 100; i++) {
                        x = THREE.Math.randFloatSpread(1000);
                        z = THREE.Math.randFloatSpread(1000);
                        gltf.scene.position.set(x, -20, z);
                        gltf.scene.name = "pesce" + i.toString();
                        gltf.scene.rotation.y = Math.random() * 6.28 - 3.14;
                        pesce[i] = THREE.Object3D.prototype.clone.call(gltf.scene)

                        //COLLISION BOXES
                        var center = new THREE.Vector3();
                        var box = new THREE.Box3().setFromObject(pesce[i]);
                        var cubeGeometry = new THREE.BoxGeometry(box.getSize(center).x, box.getSize(center).y, box.getSize(
                            center).z);
                        var wireMaterial = new THREE.MeshBasicMaterial({
                            color: 0xff0000,
                            wireframe: true
                        });
                        movingCubes[i] = new THREE.Mesh(cubeGeometry, wireMaterial);
                        movingCubes[i].position.x = pesce[i].position.x;
                        movingCubes[i].position.y = pesce[i].position.y + 2.5;
                        movingCubes[i].position.z = pesce[i].position.z;

                        collidableMeshList.push(movingCubes[i]);

                        scene.add(pesce[i]);
                        scene.add(movingCubes[i]);
                    }
                },
                function (xhr) {
                    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                },
                function (error) {
                    console.log('An error happened');
                }
            );
        }

        ///////////////////
        //FISH MOVEMENT
        ///////////////////

        function movimentoPesce(oggetto) {
            for (var i = 0; i < oggetto.length; i++) {
                var randDegrees = Math.floor(Math.random() * 720) - 360;
                var randRadians = Math.radians(randDegrees);
                var x = 0.5 * Math.cos(randRadians);
                var z = 0.5 * Math.sin(randRadians);
                if (oggetto[i].position.x + x > 500 || oggetto[i].position.x + x < -500 || oggetto[i].position.z + z >
                    500 || oggetto[i].position.z + z < -500) {
                    var rand = THREE.Math.randFloatSpread(1000);
                    oggetto[i].position.set(0, -20, 0);
                }

                function r1(oggetto, i, cubo) {

                    //TO SLOW DOWN FISH MOVEMENT, UNCOMMENT SETTIMEOUT
                    //setTimeout(function () {
                    if (randRadians > oggetto.rotation.y) {
                        var deltax = oggetto.position.x;
                        var deltaz = oggetto.position.z;
                        oggetto.rotation.y += 0.17;
                        oggetto.translateOnAxis(xAxis, -0.5);
                        deltax = oggetto.position.x - deltax;
                        deltaz = oggetto.position.z - deltaz;
                        cubo.position.x += deltax;
                        cubo.position.z += deltaz;
                        r1(oggetto, i, cubo);
                    }
                    //}, 10);
                }

                function r2(oggetto, i, cubo) {
                    //setTimeout(function () {
                    if (randRadians < oggetto.rotation.y) {
                        var deltax = oggetto.position.x;
                        var deltaz = oggetto.position.z;
                        oggetto.rotation.y -= 0.17;
                        oggetto.translateOnAxis(xAxis, -0.5);
                        deltax = oggetto.position.x - deltax;
                        deltaz = oggetto.position.z - deltaz;
                        cubo.position.x += deltax;
                        cubo.position.z += deltaz;
                        r2(oggetto, i, cubo);
                    }
                    //}, 10);
                }

                randRadians = randRadians + oggetto[i].rotation.y
                if (randRadians > oggetto[i].rotation.y) {
                    r1(oggetto[i], i, movingCubes[i]);
                } else {
                    r2(oggetto[i], i, movingCubes[i]);
                }
            }
        }

        function polarToCartesian(radius, angle) {
            return [radius * Math.cos(angle), radius * Math.sin(angle)]
        }

        ///////////////////
        //COLLISION
        ///////////////////

        function collision(obj) {
            for (var i = 0; i < obj.length; i++) {
                var originPoint = movingCubes[i].position.clone();
                for (var vertexIndex = 0; vertexIndex < movingCubes[i].geometry.vertices.length; vertexIndex++) {
                    var localVertex = movingCubes[i].geometry.vertices[vertexIndex].clone();
                    var globalVertex = localVertex.applyMatrix4(movingCubes[i].matrix);
                    var directionVector = globalVertex.sub(movingCubes[i].position);

                    var ray = new THREE.Raycaster(originPoint, directionVector.clone().normalize());
                    var collisionResults = ray.intersectObjects(collidableMeshList);
                    /* if (collisionResults.length > 0 && collisionResults[0].distance < directionVector.length())
                        console.log(" Hit "); */
                }
            }
        }

        ///////////////////
        //ANIMATION
        ///////////////////

        var animate = function () {
            requestAnimationFrame(animate);

            stats.update();
            collision(pesce);
            keyboard.update();

            if (quickTime) {
                flag = false;
                bar.progress = 0;
                progress.style.visibility = 'visible';
                bar.style.visibility = 'visible';
                UpdateBars();
                quickTime = false;
            }

            var time = performance.now() * 0.001;
            if (boatFlag) {
                boat.rotation.x = Math.sin(time) * 0.015;
            }

            if (flag) {
                movimentoPesce(pesce);
            }

            if (keyboard.down("space")) {
                bar.progress = 100;
                bar.style.visibility = 'hidden';
                progress.style.visibility = 'hidden';
                flag = true;
            }

            renderer.render(scene, camera);
        };

        animate();
    </script>
</body>

</html>