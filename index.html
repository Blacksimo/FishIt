<!DOCTYPE html>
<html>

<head>
    <link rel='icon' type='image/x-icon' href='/favicon.ico' />
    <meta charset=utf-8>
    <title>FishIT</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%
        }
    </style>
</head>

<body>
    <script src="js/three.js"></script>
    <script src="js/GLTFLoader.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/Water2.js"></script>
    <script src="js/Reflector.js"></script>
    <script src="js/Refractor.js"></script>
    <script src="js/Sky.js"></script>
    <script>
        var scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0xcce0ff, 500, 10000);
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 100000);
        var controls = new THREE.OrbitControls(camera);

        ///////////////////
        //LIGHTS & SHADOWS
        ///////////////////

        var renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
        document.body.appendChild(renderer.domElement);

        var light2 = new THREE.AmbientLight(0x404040); // soft white light
        scene.add(light2);

        var light = new THREE.DirectionalLight(0xffffff, 3);
        light.position.set(400, 400, 400);
        light.castShadow = true;
        scene.add(light);
        //Set up shadow properties for the light
        light.shadow.mapSize.width = 512;  // default
        light.shadow.mapSize.height = 512; // default
        light.shadow.camera.near = 0.5;       // default
        light.shadow.camera.far = 500      // default

        ///////////////////
        //WATER
        ///////////////////

        var params = {
            color: '#ffffff',
            scale: 4,
            flowX: 1,
            flowY: 1
        };

        var waterGeometry = new THREE.PlaneBufferGeometry(2000, 2000);
        water = new THREE.Water(waterGeometry, {
            color: params.color,
            scale: params.scale,
            flowDirection: new THREE.Vector2(params.flowX, params.flowY),
            textureWidth: 1024,
            textureHeight: 1024
        });
        water.position.y = -11;
        water.rotation.x = Math.PI * - 0.5;
        scene.add(water);


        ///////////////////
        //SKY
        ///////////////////

        // Add Sky
        sky = new THREE.Sky();
        sky.scale.setScalar(450000);
        scene.add(sky);

        // Add Sun Helper
        sunSphere = new THREE.Mesh(
            new THREE.SphereBufferGeometry(20000, 16, 8),
            new THREE.MeshBasicMaterial({ color: 0xffffff })
        );
        sunSphere.position.y = - 700000;
        sunSphere.visible = false;
        scene.add(sunSphere);

        var distance = 400000;

        var effectController = {
            turbidity: 10,
            rayleigh: 2,
            mieCoefficient: 0.005,
            mieDirectionalG: 0.8,
            luminance: 1,
            inclination: 0.49, // elevation / inclination
            azimuth: 0.25, // Facing front,
            sun: ! true
        };

        var uniforms = sky.material.uniforms;
        uniforms.turbidity.value = effectController.turbidity;
        uniforms.rayleigh.value = effectController.rayleigh;
        uniforms.luminance.value = effectController.luminance;
        uniforms.mieCoefficient.value = effectController.mieCoefficient;
        uniforms.mieDirectionalG.value = effectController.mieDirectionalG;
        var theta = Math.PI * (effectController.inclination - 0.5);
        var phi = 2 * Math.PI * (effectController.azimuth - 0.5);
        sunSphere.position.x = distance * Math.cos(phi);
        sunSphere.position.y = distance * Math.sin(phi) * Math.sin(theta);
        sunSphere.position.z = distance * Math.sin(phi) * Math.cos(theta);
        sunSphere.visible = effectController.sun;
        uniforms.sunPosition.value.copy(sunSphere.position);

        ///////////////////
        //CAMERA
        ///////////////////


        /* var geometry = new THREE.BoxGeometry(1, 1, 1);
        var material = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
        var cube = new THREE.Mesh(geometry, material);
        scene.add(cube); */

        camera.position.set(159, 10, 552);
        //camera.position.y = 5;
        camera.lookAt(0, 0, 0);
        controls.update();

        var helper = new THREE.CameraHelper(light.shadow.camera);
        scene.add(helper);

        //var r = 0;

        //Create a plane that receives shadows (but does not cast them)
        /* var planeGeometry = new THREE.PlaneBufferGeometry(1320, 1320, 1332, 1332);
        var planeMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 })
        var plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = 5;
        plane.receiveShadow = true;
        scene.add(plane); */


        ///////////////////
        //3D MODELS
        ///////////////////


        // Instantiate a loader
        var loader = new THREE.GLTFLoader();

        /* // Optional: Provide a DRACOLoader instance to decode compressed mesh data
        THREE.DRACOLoader.setDecoderPath( '/examples/js/libs/draco' );
        loader.setDRACOLoader( new THREE.DRACOLoader() ); */

        // Load a glTF resource
        loader.load(
            // resource URL
            '/models/boat+sea/noskynosea.gltf',
            // called when the resource is loaded
            function (gltf) {

                //gltf.scene.rotation.z = 180;


                gltf.scene.castShadow = true;

                //gltf.scene.position.y = 550;

                //gltf.scene.scale.set(0.05, 0.05, 0.05);


                /* var material = materials[ 0 ];
		        var object = new THREE.Mesh( geometry, material );
                object.castShadow = true;
                object.position.y = 550;
                object.scale.set(0.05, 0.05, 0.05);*/

                scene.add(gltf.scene);

                /* gltf.animations; // Array<THREE.AnimationClip>
                gltf.scene; // THREE.Scene
                gltf.scenes; // Array<THREE.Scene>
                gltf.cameras; // Array<THREE.Camera>
                gltf.asset; // Object */

            },
            // called while loading is progressing
            function (xhr) {

                console.log((xhr.loaded / xhr.total * 100) + '% loaded');

            },
            // called when loading has errors
            function (error) {

                console.log('An error happened');

            }
        );

        loader.load(
            // resource URL
            '/models/rod/scene.gltf',
            // called when the resource is loaded
            function (gltf) {

                //gltf.scene.rotation.z = 180;

                gltf.scene.position.set(170, 10, 570);
                gltf.scene.scale.set(5, 5, 5);
                gltf.scene.castShadow = true;

                //gltf.scene.position.y = 550;

                //gltf.scene.scale.set(0.05, 0.05, 0.05);


                /* var material = materials[ 0 ];
		        var object = new THREE.Mesh( geometry, material );
                object.castShadow = true;
                object.position.y = 550;
                object.scale.set(0.05, 0.05, 0.05);*/

                scene.add(gltf.scene);

                /* gltf.animations; // Array<THREE.AnimationClip>
                gltf.scene; // THREE.Scene
                gltf.scenes; // Array<THREE.Scene>
                gltf.cameras; // Array<THREE.Camera>
                gltf.asset; // Object */

            },
            // called while loading is progressing
            function (xhr) {

                console.log((xhr.loaded / xhr.total * 100) + '% loaded');

            },
            // called when loading has errors
            function (error) {

                console.log('An error happened');

            }
        );

        loader.load(
            // resource URL
            '/models/fish/scene.gltf',
            // called when the resource is loaded
            function (gltf) {

                gltf.scene.scale.set(0.05, 0.05, 0.05);
                gltf.scene.castShadow = true;

                for (var i = 0; i < 100; i++) {

                    //gltf.scene.rotation.z = 180;

                    x = THREE.Math.randFloatSpread(1000);
                    z = THREE.Math.randFloatSpread(1000);

                    gltf.scene.position.set(x, -20, z);
                    console.log(gltf.scene.position);


                    //gltf.scene.position.y = 550;

                    //gltf.scene.scale.set(0.05, 0.05, 0.05);


                    /* var material = materials[ 0 ];
                    var object = new THREE.Mesh( geometry, material );
                    object.castShadow = true;
                    object.position.y = 550;
                    object.scale.set(0.05, 0.05, 0.05);*/

                    scene.add(gltf.scene);

                }

                /* gltf.animations; // Array<THREE.AnimationClip>
                gltf.scene; // THREE.Scene
                gltf.scenes; // Array<THREE.Scene>
                gltf.cameras; // Array<THREE.Camera>
                gltf.asset; // Object */

            },
            // called while loading is progressing
            function (xhr) {

                console.log((xhr.loaded / xhr.total * 100) + '% loaded');

            },
            // called when loading has errors
            function (error) {

                console.log('An error happened');

            }
        );
        //var delta = 0;

        var animate = function () {
            requestAnimationFrame(animate);

            /* delta += 0.01;
            
            //camera.lookAt = light.position;
            camera.position.x = Math.sin(delta) * 2000;
            camera.position.z = Math.cos(delta) * 2000; */

            /* cube.rotation.x += 0.01;
            cube.rotation.y += 0.01;*/
            renderer.render(scene, camera);
        };

        animate();</script>
</body>

</html>