<!DOCTYPE html>
<html>

<head>
    <link rel='icon' type='image/x-icon' href='/favicon.ico' />
    <meta charset=utf-8>
    <title>FishIT</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%
        }
    </style>
</head>

<body>
    <script src="js/three.js"></script>
    <script src="js/GLTFLoader.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/Water2.js"></script>
    <script src="js/Reflector.js"></script>
    <script src="js/Refractor.js"></script>
    <script src="js/Sky.js"></script>
    <script src="js/libs/inflate.min.js"></script>
    <script src="js/loaders/MTLLoader.js"></script>
    <script src="js/loaders/OBJLoader.js"></script>
    <script src="js/loaders/DDSLoader.js"></script>
    <script src="js/loaders/FBXLoader.js"></script>
    <script src="js/PointerLockControls.js"></script>
    <script>
        // Converts from degrees to radians.
        Math.radians = function (degrees) {
            return degrees * Math.PI / 180;
        };

        // Converts from radians to degrees.
        Math.degrees = function (radians) {
            return radians * 180 / Math.PI;
        };

        // OGGETTI
        var pesce = [];
        var boat;
        var lighthouse;
        var boatFlag = false;
        var fishFlag = false;
        var flag = false;
        var helper;




        var scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0xcce0ff, 500, 10000);

        ///////////////////
        //CAMERA
        ///////////////////

        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 100000);
        camera.position.set(159, 10, 552);
        // camera.position.set(-43, 872, 506);
        var controls = new THREE.OrbitControls(camera);
        controls.update();
        // controls.enableZoom = false;
        //controls.enablePan = false;
        //controls.enabled = false;


        // camera.lookAt(0,0,0);
        // window.addEventListener('mousemove', function(e){
        //     var mouse3D = new THREE.Vector3(
        //     (( event.clientX / window.innerWidth ) * 2 - 1)*300,
        //     (- ( event.clientY / window.innerHeight ) * 2 + 1)*300,
        //     0.5 );
        //     camera.lookAt(mouse3D);
        // });
        //



        /* var mouseX;
        var mouseY;
        window.addEventListener('mouseMove', function(event){
            mouseX = ( event.clientX / window.innerWidth ) * 2 - 1;
            mouseY = - ( event.clientY / window.innerHeight ) * 2 + 1;
            camera.position.x += ( mouseX - camera.position.x ) ;
            camera.position.y += ( - mouseY - camera.position.y ) ;
            camera.lookAt( scene.position );
        }) */

        /* var looking = new THREE.PointerLockControls( camera );
        scene.add( looking.getObject() ); */
        //looking.enabled = true; // Turns on camera rotating with mouse

        ///////////////////
        //LIGHTS & SHADOWS
        ///////////////////

        var renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
        document.body.appendChild(renderer.domElement);

        var light2 = new THREE.AmbientLight(0x404040); // soft white light
        scene.add(light2);

        var light = new THREE.DirectionalLight(0xffffff, 3);
        light.position.set(400, 400, 400);
        light.castShadow = true;
        scene.add(light);
        //Set up shadow properties for the light
        light.shadow.mapSize.width = 512; // default
        light.shadow.mapSize.height = 512; // default
        light.shadow.camera.near = 0.5; // default
        light.shadow.camera.far = 500 // default

        ///////////////////
        //WATER
        ///////////////////

        var params = {
            color: '#ffffff',
            scale: 4,
            flowX: 1,
            flowY: 1
        };

        var waterGeometry = new THREE.PlaneBufferGeometry(2000, 2000);
        water = new THREE.Water(waterGeometry, {
            color: params.color,
            scale: params.scale,
            flowDirection: new THREE.Vector2(params.flowX, params.flowY),
            textureWidth: 1024,
            textureHeight: 1024
        });
        water.position.y = -11;
        water.rotation.x = Math.PI * -0.5;
        scene.add(water);


        ///////////////////
        //SKY
        ///////////////////

        // Add Sky
        sky = new THREE.Sky();
        sky.scale.setScalar(450000);
        scene.add(sky);

        // Add Sun Helper
        sunSphere = new THREE.Mesh(
            new THREE.SphereBufferGeometry(20000, 16, 8),
            new THREE.MeshBasicMaterial({
                color: 0xffffff
            })
        );
        sunSphere.position.y = -700000;
        //sunSphere.position.x = -500000;
        sunSphere.visible = false;
        scene.add(sunSphere);

        var distance = 400000;

        var effectController = {
            turbidity: 10,
            rayleigh: 2,
            mieCoefficient: 0.005,
            mieDirectionalG: 0.8,
            luminance: 1,
            inclination: 0.55, // elevation / inclination
            azimuth: 0.6, // Facing front,
            sun: !true
        };

        var uniforms = sky.material.uniforms;
        uniforms.turbidity.value = effectController.turbidity;
        uniforms.rayleigh.value = effectController.rayleigh;
        uniforms.luminance.value = effectController.luminance;
        uniforms.mieCoefficient.value = effectController.mieCoefficient;
        uniforms.mieDirectionalG.value = effectController.mieDirectionalG;
        var theta = Math.PI * (effectController.inclination - 0.5);
        var phi = 2 * Math.PI * (effectController.azimuth - 0.5);
        sunSphere.position.x = distance * Math.cos(phi);
        sunSphere.position.y = distance * Math.sin(phi) * Math.sin(theta);
        sunSphere.position.z = distance * Math.sin(phi) * Math.cos(theta);
        sunSphere.visible = effectController.sun;
        uniforms.sunPosition.value.copy(sunSphere.position);

        ///////////////////
        //CAMERA
        ///////////////////


        /* var geometry = new THREE.BoxGeometry(1, 1, 1);
        var material = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
        var cube = new THREE.Mesh(geometry, material);
        scene.add(cube); */


        //camera.position.y = 5;
        //camera.lookAt(mouse3D);


        //var helper = new THREE.CameraHelper(light.shadow.camera);
        //scene.add(helper);

        //var r = 0;

        //Create a plane that receives shadows (but does not cast them)
        /* var planeGeometry = new THREE.PlaneBufferGeometry(1320, 1320, 1332, 1332);
        var planeMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 })
        var plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = 5;
        plane.receiveShadow = true;
        scene.add(plane); */


        ///////////////////
        //3D MODELS
        ///////////////////


        var loader = new THREE.GLTFLoader();

        loader.load(
            // resource URL
            '/models/lighthouse/model.gltf',
            // called when the resource is loaded
            function (gltf) {

                //gltf.scene.rotation.z = 180;


                gltf.scene.castShadow = true;
                gltf.scene.name = "lighthouse";
                gltf.scene.position.y = -13;



                // gltf.scene.position.set(270, -8, 600)
                // gltf.scene.scale.set(10, 10, 10)
                //gltf.scene.rotation.y = 0.78



                /* var material = materials[ 0 ];
            var object = new THREE.Mesh( geometry, material );
                object.castShadow = true;
                object.position.y = 550;
                object.scale.set(0.05, 0.05, 0.05);*/
                lighthouse = gltf.scene;

                scene.add(lighthouse);

                /* gltf.animations; // Array<THREE.AnimationClip>
                gltf.scene; // THREE.Scene
                gltf.scenes; // Array<THREE.Scene>
                gltf.cameras; // Array<THREE.Camera>
                gltf.asset; // Object */

            },
            // called while loading is progressing
            function (xhr) {

                console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                if (xhr.loaded / xhr.total == 1) {

                }

            },
            // called when loading has errors
            function (error) {

                console.log('An error happened');

            }
        );

        loader.load(
            // resource URL
            '/models/boat/scene.gltf',
            // called when the resource is loaded
            function (gltf) {

                //gltf.scene.rotation.z = 180;


                gltf.scene.castShadow = true;
                gltf.scene.name = "boat";



                gltf.scene.position.set(270, -8, 600)
                gltf.scene.scale.set(10, 10, 10)
                //gltf.scene.rotation.y = 0.78



                /* var material = materials[ 0 ];
		        var object = new THREE.Mesh( geometry, material );
                object.castShadow = true;
                object.position.y = 550;
                object.scale.set(0.05, 0.05, 0.05);*/
                boat = gltf.scene;

                scene.add(boat);
                boatFlag = true;

                /* gltf.animations; // Array<THREE.AnimationClip>
                gltf.scene; // THREE.Scene
                gltf.scenes; // Array<THREE.Scene>
                gltf.cameras; // Array<THREE.Camera>
                gltf.asset; // Object */

            },
            // called while loading is progressing
            function (xhr) {

                console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                if (xhr.loaded / xhr.total == 1) {

                }

            },
            // called when loading has errors
            function (error) {

                console.log('An error happened');

            }
        );

        loader.load(
            // resource URL
            '/models/rod/scene.gltf',
            // called when the resource is loaded
            function (gltf) {

                //gltf.scene.rotation.z = 180;

                gltf.scene.position.set(170, 10, 570);
                gltf.scene.scale.set(5, 5, 5);
                gltf.scene.castShadow = true;

                //gltf.scene.position.y = 550;

                //gltf.scene.scale.set(0.05, 0.05, 0.05);


                /* var material = materials[ 0 ];
		        var object = new THREE.Mesh( geometry, material );
                object.castShadow = true;
                object.position.y = 550;
                object.scale.set(0.05, 0.05, 0.05);*/

                scene.add(gltf.scene);

                /* gltf.animations; // Array<THREE.AnimationClip>
                gltf.scene; // THREE.Scene
                gltf.scenes; // Array<THREE.Scene>
                gltf.cameras; // Array<THREE.Camera>
                gltf.asset; // Object */

            },
            // called while loading is progressing
            function (xhr) {

                console.log((xhr.loaded / xhr.total * 100) + '% loaded');

            },
            // called when loading has errors
            function (error) {

                console.log('An error happened');

            }
        );

        loader.load(
            // resource URL
            '/models/fish/scene.gltf',
            // called when the resource is loaded
            function (gltf) {

                gltf.scene.scale.set(0.05, 0.05, 0.05);
                gltf.scene.castShadow = true;

                for (var i = 0; i < 100; i++) {

                    //gltf.scene.rotation.z = 180;

                    x = THREE.Math.randFloatSpread(1000);
                    z = THREE.Math.randFloatSpread(1000);

                    gltf.scene.position.set(x, -20, z);
                    //console.log(gltf.scene.position);
                    gltf.scene.name = "pesce" + i.toString();

                    gltf.scene.rotation.y = Math.random() * 6.28 - 3.14;


                    //gltf.scene.position.y = 550;

                    //gltf.scene.scale.set(0.05, 0.05, 0.05);


                    /* var material = materials[ 0 ];
                    var object = new THREE.Mesh( geometry, material );
                    object.castShadow = true;
                    object.position.y = 550;
                    object.scale.set(0.05, 0.05, 0.05);*/

                    pesce[i] = THREE.Object3D.prototype.clone.call(gltf.scene)

                    scene.add(pesce[i]);
                    //fishFlag = true;

                }

                /* gltf.animations; // Array<THREE.AnimationClip>
                gltf.scene; // THREE.Scene
                gltf.scenes; // Array<THREE.Scene>
                gltf.cameras; // Array<THREE.Camera>
                gltf.asset; // Object */

            },
            // called while loading is progressing
            function (xhr) {

                console.log((xhr.loaded / xhr.total * 100) + '% loaded');

            },
            // called when loading has errors
            function (error) {

                console.log('An error happened');

            }
        );
        //var delta = 0;

        ///////////////////
        //FISH MOVEMENT
        ///////////////////

        var xAxis = new THREE.Vector3(1, 0, 0);

        function movimentoPesce(oggetto) {
            /* var randDegrees;
            var randRadians; */
            //fishFlag = false;
            for (var i = 0; i < oggetto.length; i++) {

                //fishFlag=false;
                var randDegrees = Math.floor(Math.random() * 720) - 360;
                var randRadians = Math.radians(randDegrees);
                var x = 0.5 * Math.cos(randRadians);
                var z = 0.5 * Math.sin(randRadians);
                if (oggetto[i].position.x + x > 500 || oggetto[i].position.x + x < -500 || oggetto[i].position.z + z >
                    500 || oggetto[i].position.z + z < -500) {
                    var rand = THREE.Math.randFloatSpread(1000);
                    oggetto[i].position.set(0, -20, 0);
                }

                /* 
                console.log("radianti randomici:", randRadians);
                console.log("radianti del pesce:", oggetto[i].rotation.y); 
                console.log(randRadians > oggetto[i].rotation.y); */

                function r1(oggetto) {
                    //console.log("ciclo1");
                    //setTimeout(function () {

                    //console.log(oggetto[i])
                    if (randRadians > oggetto.rotation.y) {
                        //setTimeout(function () {
                        oggetto.rotation.y += 0.17;
                        oggetto.translateOnAxis(xAxis, -0.5);
                        //}, 100);
                        r1(oggetto);
                    }
                    //}, 1);

                }

                function r2(oggetto) {
                    //console.log("ciclo2");
                    //setTimeout(function () {


                    if (randRadians < oggetto.rotation.y) {
                        //setTimeout(function () {
                        oggetto.rotation.y -= 0.17;
                        oggetto.translateOnAxis(xAxis, -0.5);
                        //}, 100);
                        r2(oggetto);
                    }
                    //}, 1);

                }

                randRadians = randRadians + oggetto[i].rotation.y

                if (randRadians > oggetto[i].rotation.y) {

                    r1(oggetto[i]);


                } else {

                    r2(oggetto[i]);

                    //fishFlag=true;
                }


            }

            //console.log("sono uscito dal for");
            //fishFlag = true;
            //movimentoPesce(oggetto);

        }




        /* setTimeout(function(){
                for (var p = 0; p < pesce.length; p++){

                    pesce[p].rotateY(Math.radians(Math.floor(Math.random() * 360) - 180));
                    pesce[p].translateOnAxis(xAxis, 10);
                //pesce[p].position.x -= 0.5;
                //movimentoPesce(pesce[p], Math.radians(Math.floor(Math.random() * 360) - 180));
                //pesce[p].position.x-=0.3
                }
                if (boatFlag){
                boat.rotateY(0.017);
                boat.translateOnAxis(diocane, 10);
                }
            }, 3000); */

        /* if (fishFlag) {
            setTimeout(function () {
                movimentoPesce(pesce);
            }, 100);

        } */

        function polarToCartesian(radius, angle) {
            return [radius * Math.cos(angle), radius * Math.sin(angle)]
        }

        ///////////////////
        //COLLISION
        ///////////////////

        var cubeGeometry = new THREE.CubeGeometry(50, 50, 50, 1, 1, 1);
        var wireMaterial = new THREE.MeshBasicMaterial({
            color: 0xff0000,
            wireframe: true
        });
        MovingCube = new THREE.Mesh(cubeGeometry, wireMaterial);
        MovingCube.position.set(0, 25.1, 0);
        scene.add(MovingCube);

        function update() {
            var delta = clock.getDelta(); // seconds.
            var moveDistance = 200 * delta; // 200 pixels per second
            var rotateAngle = Math.PI / 2 * delta; // pi/2 radians (90 degrees) per second

            if (keyboard.pressed("A"))
                MovingCube.rotation.y += rotateAngle;
            if (keyboard.pressed("D"))
                MovingCube.rotation.y -= rotateAngle;

            if (keyboard.pressed("left"))
                MovingCube.position.x -= moveDistance;
            if (keyboard.pressed("right"))
                MovingCube.position.x += moveDistance;
            if (keyboard.pressed("up"))
                MovingCube.position.z -= moveDistance;
            if (keyboard.pressed("down"))
                MovingCube.position.z += moveDistance;

            // collision detection:
            //   determines if any of the rays from the cube's origin to each vertex
            //		intersects any face of a mesh in the array of target meshes
            //   for increased collision accuracy, add more vertices to the cube;
            //		for example, new THREE.CubeGeometry( 64, 64, 64, 8, 8, 8, wireMaterial )
            //   HOWEVER: when the origin of the ray is within the target mesh, collisions do not occur
            var originPoint = MovingCube.position.clone();
            clearText();

            for (var vertexIndex = 0; vertexIndex < MovingCube.geometry.vertices.length; vertexIndex++) {
                var localVertex = MovingCube.geometry.vertices[vertexIndex].clone();
                var globalVertex = localVertex.applyMatrix4(MovingCube.matrix);
                var directionVector = globalVertex.sub(MovingCube.position);

                var ray = new THREE.Raycaster(originPoint, directionVector.clone().normalize());
                var collisionResults = ray.intersectObjects(collidableMeshList);
                if (collisionResults.length > 0 && collisionResults[0].distance < directionVector.length())
                    appendText(" Hit ");
            }
            controls.update();
            stats.update();
        }








        //
        var animate = function () {
            requestAnimationFrame(animate);

            /* for (var p = 0; p < pesce.length; p++) {
                movimentoPesce(pesce[p], Math.radians(Math.floor(Math.random() * 360) - 180));
            } */
            /* if (fishFlag) {
                setTimeout(function(){movimentoPesce(pesce);
                }, 1000);

            } */


            //movimentoPesce(pesce);

            //movimentoPesce(pesce);
            var time = performance.now() * 0.001;
            if (boatFlag) {
                boat.rotation.x = Math.sin(time) * 0.015;
                //movimentoPesce(boat, 0.17)
                //boat.position.y = Math.sin(time) * 20 + 5;
            }

            //.movimentoPesce(Math.radians(Math.floor(Math.random() * 360) - 180));

            if (flag) {
                helper = new THREE.BoundingBoxHelper(boat, 0xff0000);
                helper.position = boat.position;
                helper.update();
                // If you want a visible bounding box
                scene.add(helper);
                flag = false;
                
            }


            //camera.lookAt(mouse3D);
            /* delta += 0.01;

                //camera.lookAt = light.position;
                camera.position.x = Math.sin(delta) * 2000;
                camera.position.z = Math.cos(delta) * 2000; */

            /* cube.rotation.x += 0.01;
            cube.rotation.y += 0.01;*/
            renderer.render(scene, camera);
        };

        animate();
    </script>
</body>

</html>